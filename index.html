<div style="margin: 5%;">
<div style="float: right;">
<a href="/zh"> 中文</a>
</div>
<h1 align="center">Yiyang Chen's project demos</h1>
<p align="center">
    Master of Computer graphics and game technology, University of Pennsylvania <br />
    Email: yiyangch@seas.upenn.edu
</p>

<h2>Geometry Optimization Authoring Tool</h2>
<p>
    Based on papers "Shape-Up: Shaping Discrete Geometry with Projections" and "Anderson Acceleration for Geometry Optimization and Physics Simulation", made an authoring tool with C++. We implemented some operations for input model, including planarization, wire mesh design and ARAP deforamtion.
</p>
<p>
    We make a standalone application as well as a maya plugin. 
</p>
<p>
    <a href="https://drive.google.com/file/d/1pLaFTvVHWPGburol8jJRtyzvEKDmvrgg/view?usp=sharing"> Standalone application video</a>   
</p>
<p>
    <a href="https://drive.google.com/file/d/19elzxffSRF5A9Qw9Ha57ZZX0cIkeezQo/view?usp=sharing"> Presentation video</a>    
</p>
<p> 
    <a href="https://docs.google.com/presentation/d/1yPMS9ocDrQ96YBwME75GZV7nYWBDC5c2/edit?usp=sharing&ouid=110710600029969113633&rtpof=true&sd=true"> Slides</a>
</p>
<p><br/></p>

<h2>Physically Based Rendering Program</h2>
<p>
    Made a physically based rendering CPU program using C++ and Qt. I implemented the path tracing algorithm, and I used multiple importance sampling (MIS) to estimate contribution of each vertex on the path.
</p>
<p>
    The program first loads a scene file in JSON format and then renders with user-defined sample times, recursion limit and integrator type. In the integrate type option, "Surface Normals" just render the surface normal of the scene; "Full Lighting" is the path tracing integrator; and "Direct Lighting" just compute the direct light with MIS, which can be regarded as "Full Lighting" with recursion limit 1.
</p>
<p>
    Also made a GPU program with the same algorithm. 
</p>
<p>
    See the following video. The first is CPU rendering program and the second is GPU. Some part of the render process in the CPU program is clipped.
</p>
<video height="600" controls>
    <source src="PBR.mp4" type="video/mp4">
</video>
<video height="600" controls>
    <source src="GPUPBR.mp4" type="video/mp4">
</video>
<p><br/></p>

<h2>Mini Minecraft</h2>
<p>
    Made a Mini Minecraft game using Qt and OpenGL. Player can move around in fly mode and ground mode, and create or destroy nearby blocks. The terrain is procedual generated, and thus has no boundary. The following videos demonstrate all the features we implemented in the game.
</p>
<iframe src="https://drive.google.com/file/d/1ka8l8ARFGWb50GoiU8JiabMgdnZb5vuF/preview" width="640" height="480" allow="autoplay"></iframe>

<p><br /></p>


<h2>LSystem Plugin for Maya and Houdini</h2>
<p>
    Made a simple Maya LSystem plugin and a Houdini LSystem plugin. Input grammar, iterations, angle and step size, you can get the generated model.
</p>
<video height="400" controls>
    <source src="maya.mp4" type="video/mp4">
</video>
<video height="400" controls>
    <source src="houdini.mp4" type="video/mp4">
</video>
<p><br/></p>

<h2>Mesh and Skeleton Editor</h2>
<p>
    Made a mesh and skeleton editor using Qt and OpenGL with half-edge mesh structure. It can load model file in "obj" format and skeleton file in "json" format and then edit them. Implemented operations include ray casting selection, add midpoint, triangulate, subdivision, two methods of skinning, and two methods of blending.
</p>
<video height="300" controls>
    <source src="half-edge_mesh_editor_demo1.mp4" type="video/mp4">
</video>
<video height="300" controls>
    <source src="half-edge_mesh_editor_demo2.mp4" type="video/mp4">
</video>

<p><br/></p>


<h2>Small Unreal Games</h2>
<p>
    Made 2 small games with UE4 engine
</p>
<iframe src="https://drive.google.com/file/d/170s1MsJf6DU7YrZEPKnJyTd8J5IClmyB/preview" width="640" height="480" allow="autoplay"></iframe>
<p>
    This game is a little similar to "Monument Valley", involving optical illusion under specific view. You should change the camera views to find new road and finally reach destination.
</p>
<p><br/></p>

<iframe width="1068" height="601" src="https://www.youtube.com/embed/-eCOsB2__f0" title="3dPinball" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p>
    This is a VR game, can be regarded as the 3D version of "Full Tilt! Pinball". You need to use your controllers to hit the ball to prevent it from falling behind, and make the ball hit various types of objects to get score.
</p>
<p><br/></p>

<h2>Funny Render effect</h2>
<p>Implemented some interesting render effect in OpenGL.</p>
<div style="float: left; margin-right: 3%;">
    <p>Vertex deformation:</p>
    <img src="vertex_deformation.gif" height="480">
</div>
<div style="float: left;">
    <p>Post processing:</p>
    <img src="post_processing.gif" height="480">
</div>
<div style="clear: both;"></div>
<p><br/></p>

<h2>Forward Kinematic and Inverse Kinematic</h2>
<p>Implemented forward kinematic and some inverse kinematic methods including CCD Algorithm, geometry and pseudo inverse. And used IK in the walk cycle</p>
<div style="float: left; margin-right: 3%;">
    <video height="480" controls>
        <source src="fk_and_ik.mp4" type="video/mp4">
    </video>
</div>
<div style="float: left;">
    <img src="fook_ik.gif" height="300">
</div>
<div style="clear: both;"></div>
<p><br/></p>

<p><br/></p>
<h2>Fixed foveated Rendering</h2>
<p>Implemented a fixed foveated rendering with pixel discard and recover in Unity</p>
<video height="480" controls>
    <source src="simple_forveated_rendering_demo.mp4" type="video/mp4">
</video>
</div>